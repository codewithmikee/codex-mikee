import { ScriptRequest } from '../types';

/**
 * Generates a shell script based on the provided request
 */
export async function generateShellScript(request: ScriptRequest): Promise<string> {
  // In a real implementation, this would use an AI model or more complex logic
  // For now, we'll use a template-based approach
  
  const { task, details, technologies } = request;
  
  // Determine script type based on task
  let scriptTemplate = '';
  
  switch (task) {
    case 'Create a new app in the monorepo':
      scriptTemplate = generateAppCreationScript(details, technologies);
      break;
    case 'Create a new backend service':
      scriptTemplate = generateBackendServiceScript(details, technologies);
      break;
    case 'Add a new package to the workspace':
      scriptTemplate = generatePackageScript(details, technologies);
      break;
    case 'Setup TypeScript configuration':
      scriptTemplate = generateTSConfigScript(details, technologies);
      break;
    case 'Configure pnpm workspaces':
      scriptTemplate = generatePnpmWorkspaceScript(details, technologies);
      break;
    case 'Custom script':
    default:
      scriptTemplate = generateCustomScript(details, technologies);
      break;
  }
  
  return scriptTemplate;
}

function generateAppCreationScript(details: string, technologies: string[]): string {
  return `#!/bin/bash

# Script to create a new Next.js app in the AI Workspace monorepo
# Generated for: Create a new app in the monorepo

# Set colors for better readability
GREEN='\\033[0;32m'
CYAN='\\033[0;36m'
YELLOW='\\033[1;33m'
RED='\\033[0;31m'
NC='\\033[0m' # No Color

echo -e "${CYAN}=== AI Workspace Monorepo - App Generator ===${NC}\\n"

# Check if app name is provided
if [ -z "$1" ]; then
  echo -e "${RED}Error: Please provide an app name.${NC}"
  echo -e "Usage: ./create-app.sh <app-name>"
  exit 1
fi

APP_NAME=$1
APP_PATH="apps/$APP_NAME"

# Check if the app already exists
if [ -d "$APP_PATH" ]; then
  echo -e "${RED}Error: An app with name '$APP_NAME' already exists.${NC}"
  exit 1
fi

echo -e "${YELLOW}Creating new Next.js app: ${GREEN}$APP_NAME${NC}"
echo -e "${YELLOW}Path: ${GREEN}$APP_PATH${NC}\\n"

# Create the app directory
mkdir -p "$APP_PATH"

# Change to the app directory
cd "$APP_PATH"

# Create the app structure with TypeScript and src/ folder
echo -e "${CYAN}Setting up app structure...${NC}"
mkdir -p src/app src/components src/lib

# Create the package.json file
cat > package.json << EOL
{
  "name": "@workspace/$APP_NAME",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint"
  },
  "dependencies": {
    "next": "^13.4.0",
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "@workspace/ui": "workspace:*",
    "@workspace/shared": "workspace:*"
  },
  "devDependencies": {
    "@types/node": "^18.0.0",
    "@types/react": "^18.0.0",
    "@types/react-dom": "^18.0.0",
    "typescript": "^5.0.0",
    "tailwindcss": "^3.3.0",
    "autoprefixer": "^10.4.0",
    "postcss": "^8.4.0"
  }
}
EOL

# Create tsconfig.json
cat > tsconfig.json << EOL
{
  "extends": "../../packages/config/tsconfig.nextjs.json",
  "compilerOptions": {
    "baseUrl": ".",
    "paths": {
      "@/*": ["./src/*"],
      "@workspace/*": ["../../packages/*"]
    }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx"],
  "exclude": ["node_modules"]
}
EOL

# Create the Next.js config file
cat > next.config.js << EOL
/** @type {import('next').NextConfig} */
const nextConfig = {
  reactStrictMode: true,
  transpilePackages: ["@workspace/ui", "@workspace/shared"]
}

module.exports = nextConfig
EOL

# Setup Tailwind CSS
cat > tailwind.config.js << EOL
/** @type {import('tailwindcss').Config} */
module.exports = {
  presets: [require('../../packages/ui/tailwind.config.js')],
  content: [
    './src/**/*.{js,ts,jsx,tsx}',
    '../../packages/ui/src/**/*.{js,ts,jsx,tsx}'
  ],
  theme: {
    extend: {},
  },
  plugins: [],
}
EOL

cat > postcss.config.js << EOL
module.exports = {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}
EOL

# Create a basic layout file
cat > src/app/layout.tsx << EOL
import '@/styles/globals.css'
import { Inter } from 'next/font/google'

const inter = Inter({ subsets: ['latin'] })

export const metadata = {
  title: '$APP_NAME',
  description: 'Generated by AI Workspace',
}

export default function RootLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return (
    <html lang="en">
      <body className={inter.className}>{children}</body>
    </html>
  )
}
EOL

# Create a simple page component
cat > src/app/page.tsx << EOL
import { Button } from '@workspace/ui'

export default function Home() {
  return (
    <main className="flex min-h-screen flex-col items-center justify-center p-24">
      <h1 className="text-4xl font-bold mb-8">
        Welcome to {process.env.NEXT_PUBLIC_APP_NAME || '$APP_NAME'}
      </h1>
      <p className="mb-4">
        This app was created using the AI Workspace monorepo structure
      </p>
      <Button>Get Started</Button>
    </main>
  )
}
EOL

# Create styles directory and global CSS
mkdir -p src/styles
cat > src/styles/globals.css << EOL
@tailwind base;
@tailwind components;
@tailwind utilities;
EOL

# Create a README.md file
cat > README.md << EOL
# $APP_NAME

This is a Next.js application created within the AI Workspace monorepo.

## Getting Started

First, run the development server:

\`\`\`bash
pnpm dev
\`\`\`

Open [http://localhost:3000](http://localhost:3000) with your browser to see the result.

## Learn More

To learn more about the technologies used:

- [Next.js Documentation](https://nextjs.org/docs)
- [Tailwind CSS Documentation](https://tailwindcss.com/docs)
- [ShadCN UI Documentation](https://ui.shadcn.com)
EOL

# Return to the original directory
cd ../..

echo -e "\\n${GREEN}Successfully created $APP_NAME!${NC}"
echo -e "${YELLOW}To start the development server:${NC}"
echo -e "  cd $APP_PATH"
echo -e "  pnpm dev\\n"
echo -e "${CYAN}Happy coding!${NC}"`;
}

function generateBackendServiceScript(details: string, technologies: string[]): string {
  return `#!/bin/bash

# Script to create a new Express.js backend service in the AI Workspace monorepo
# Generated for: Create a new backend service

# Set colors for better readability
GREEN='\\033[0;32m'
CYAN='\\033[0;36m'
YELLOW='\\033[1;33m'
RED='\\033[0;31m'
NC='\\033[0m' # No Color

echo -e "${CYAN}=== AI Workspace Monorepo - Backend Service Generator ===${NC}\\n"

# Check if service name is provided
if [ -z "$1" ]; then
  echo -e "${RED}Error: Please provide a service name.${NC}"
  echo -e "Usage: ./create-server.sh <service-name>"
  exit 1
fi

SERVICE_NAME=$1
SERVICE_PATH="servers/$SERVICE_NAME"

# Check if the service already exists
if [ -d "$SERVICE_PATH" ]; then
  echo -e "${RED}Error: A service with name '$SERVICE_NAME' already exists.${NC}"
  exit 1
fi

echo -e "${YELLOW}Creating new Express.js service: ${GREEN}$SERVICE_NAME${NC}"
echo -e "${YELLOW}Path: ${GREEN}$SERVICE_PATH${NC}\\n"

# Create the service directory
mkdir -p "$SERVICE_PATH/src/routes" "$SERVICE_PATH/src/services" "$SERVICE_PATH/src/types"

# Change to the service directory
cd "$SERVICE_PATH"

# Create package.json
cat > package.json << EOL
{
  "name": "$SERVICE_NAME",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "tsx watch src/index.ts",
    "build": "tsc",
    "start": "node dist/index.js",
    "lint": "eslint src --ext .ts"
  },
  "dependencies": {
    "express": "^4.18.2",
    "cors": "^2.8.5",
    "zod": "^3.21.4",
    "@workspace/shared": "workspace:*"
  },
  "devDependencies": {
    "@types/express": "^4.17.17",
    "@types/cors": "^2.8.13",
    "@types/node": "^18.15.11",
    "tsx": "^3.12.6",
    "typescript": "^5.0.4"
  }
}
EOL

# Create tsconfig.json
cat > tsconfig.json << EOL
{
  "extends": "../../packages/config/tsconfig.node.json",
  "compilerOptions": {
    "outDir": "./dist",
    "baseUrl": ".",
    "paths": {
      "@/*": ["./src/*"],
      "@workspace/*": ["../../packages/*"]
    }
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "dist"]
}
EOL

# Create main server file
cat > src/index.ts << EOL
import express from 'express';
import cors from 'cors';

const app = express();
const PORT = process.env.PORT || 8000;

// Middleware
app.use(cors());
app.use(express.json());

// Health check
app.get('/health', (req, res) => {
  res.status(200).json({ status: 'ok' });
});

// Define your routes here
// e.g. app.use('/api/users', userRoutes);

// Start server
app.listen(PORT, '0.0.0.0', () => {
  console.log(\`$SERVICE_NAME service running on http://0.0.0.0:\${PORT}\`);
});
EOL

# Create a sample route file
cat > src/routes/index.ts << EOL
import express from 'express';

const router = express.Router();

/**
 * GET /api
 * Basic API information
 */
router.get('/', (req, res) => {
  res.json({
    service: '$SERVICE_NAME',
    version: '0.1.0',
    endpoints: [
      { path: '/health', method: 'GET', description: 'Health check endpoint' }
    ]
  });
});

export default router;
EOL

# Create types file
cat > src/types/index.ts << EOL
import { z } from 'zod';

// Define your custom types and zod schemas here
EOL

# Create README.md
cat > README.md << EOL
# $SERVICE_NAME

This is an Express.js backend service created within the AI Workspace monorepo.

## Getting Started

First, run the development server:

\`\`\`bash
pnpm dev
\`\`\`

The service will be running on http://localhost:8000.

## API Endpoints

- \`GET /health\`: Health check endpoint

## Learn More

To learn more about the technologies used:

- [Express.js Documentation](https://expressjs.com/)
- [TypeScript Documentation](https://www.typescriptlang.org/docs/)
- [Zod Documentation](https://zod.dev/)
EOL

# Return to the original directory
cd ../..

echo -e "\\n${GREEN}Successfully created $SERVICE_NAME!${NC}"
echo -e "${YELLOW}To start the development server:${NC}"
echo -e "  cd $SERVICE_PATH"
echo -e "  pnpm dev\\n"
echo -e "${CYAN}Happy coding!${NC}"`;
}

function generatePackageScript(details: string, technologies: string[]): string {
  return `#!/bin/bash

# Script to create a new package in the AI Workspace monorepo
# Generated for: Add a new package to the workspace

# Set colors for better readability
GREEN='\\033[0;32m'
CYAN='\\033[0;36m'
YELLOW='\\033[1;33m'
RED='\\033[0;31m'
NC='\\033[0m' # No Color

echo -e "${CYAN}=== AI Workspace Monorepo - Package Generator ===${NC}\\n"

# Check if package name is provided
if [ -z "$1" ]; then
  echo -e "${RED}Error: Please provide a package name.${NC}"
  echo -e "Usage: ./create-package.sh <package-name>"
  exit 1
fi

PKG_NAME=$1
PKG_PATH="packages/$PKG_NAME"

# Check if the package already exists
if [ -d "$PKG_PATH" ]; then
  echo -e "${RED}Error: A package with name '$PKG_NAME' already exists.${NC}"
  exit 1
fi

echo -e "${YELLOW}Creating new package: ${GREEN}$PKG_NAME${NC}"
echo -e "${YELLOW}Path: ${GREEN}$PKG_PATH${NC}\\n"

# Create the package directory
mkdir -p "$PKG_PATH/src"

# Change to the package directory
cd "$PKG_PATH"

# Create package.json
cat > package.json << EOL
{
  "name": "@workspace/$PKG_NAME",
  "version": "0.1.0",
  "private": true,
  "main": "dist/index.js",
  "types": "dist/index.d.ts",
  "scripts": {
    "build": "tsc",
    "dev": "tsc --watch",
    "lint": "eslint src --ext .ts,.tsx"
  },
  "dependencies": {
  },
  "devDependencies": {
    "typescript": "^5.0.4"
  },
  "peerDependencies": {
  }
}
EOL

# Create tsconfig.json
cat > tsconfig.json << EOL
{
  "extends": "../../packages/config/tsconfig.base.json",
  "compilerOptions": {
    "outDir": "./dist",
    "rootDir": "./src",
    "composite": true,
    "declaration": true,
    "declarationMap": true,
    "sourceMap": true
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "dist"]
}
EOL

# Create index.ts
cat > src/index.ts << EOL
/**
 * @workspace/$PKG_NAME
 * 
 * Package description goes here
 */

// Export your package contents here
// Example:
// export { default as MyComponent } from './components/MyComponent';
// export type { MyComponentProps } from './types';
EOL

# Create README.md
cat > README.md << EOL
# @workspace/$PKG_NAME

This is a package created within the AI Workspace monorepo.

## Installation

This package is available as part of the monorepo and can be installed via pnpm:

\`\`\`bash
pnpm add @workspace/$PKG_NAME
\`\`\`

## Usage

\`\`\`typescript
import { /* components or functions */ } from '@workspace/$PKG_NAME';

// Usage examples go here
\`\`\`

## API Reference

Documentation for the package API goes here.
EOL

# Return to the original directory
cd ../..

echo -e "\\n${GREEN}Successfully created package: $PKG_NAME!${NC}"
echo -e "${YELLOW}To build the package:${NC}"
echo -e "  pnpm --filter @workspace/$PKG_NAME build\\n"
echo -e "${CYAN}Happy coding!${NC}"`;
}

function generateTSConfigScript(details: string, technologies: string[]): string {
  return `#!/bin/bash

# Script to setup TypeScript configuration in the AI Workspace monorepo
# Generated for: Setup TypeScript configuration

# Set colors for better readability
GREEN='\\033[0;32m'
CYAN='\\033[0;36m'
YELLOW='\\033[1;33m'
RED='\\033[0;31m'
NC='\\033[0m' # No Color

echo -e "${CYAN}=== AI Workspace Monorepo - TypeScript Configuration ===${NC}\\n"

# Create or update the root tsconfig.json
echo -e "${YELLOW}Setting up root TypeScript configuration...${NC}"

cat > tsconfig.json << EOL
{
  "compilerOptions": {
    "strict": true,
    "module": "ESNext",
    "moduleResolution": "bundler",
    "skipLibCheck": true,
    "esModuleInterop": true,
    "lib": ["ESNext", "DOM", "DOM.Iterable"],
    "jsx": "preserve",
    "composite": true,
    "declaration": true,
    "noEmit": true,
    "resolveJsonModule": true,
    "paths": {
      "@workspace/*": ["./packages/*"]
    }
  },
  "include": [],
  "exclude": ["node_modules", "dist", "build", "**/*.test.ts"],
  "references": [
    { "path": "./packages/config" },
    { "path": "./packages/ui" },
    { "path": "./packages/shared" },
    { "path": "./apps/shell-ui" },
    { "path": "./servers/shell-ai" }
  ]
}
EOL

# Create the config package if it doesn't exist
CONFIG_PATH="packages/config"
if [ ! -d "$CONFIG_PATH" ]; then
  echo -e "${YELLOW}Creating config package...${NC}"
  mkdir -p "$CONFIG_PATH"
  
  # Create package.json for the config package
  cat > "$CONFIG_PATH/package.json" << EOL
{
  "name": "@workspace/config",
  "version": "0.1.0",
  "private": true,
  "files": [
    "tsconfig.base.json",
    "tsconfig.nextjs.json",
    "tsconfig.node.json"
  ]
}
EOL

  # Create base TypeScript config
  cat > "$CONFIG_PATH/tsconfig.base.json" << EOL
{
  "compilerOptions": {
    "target": "ES2020",
    "lib": ["ESNext", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "moduleResolution": "bundler",
    "esModuleInterop": true,
    "strict": true,
    "strictNullChecks": true,
    "strictFunctionTypes": true,
    "declaration": true,
    "declarationMap": true,
    "sourceMap": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "noImplicitReturns": true,
    "noFallthroughCasesInSwitch": true,
    "useDefineForClassFields": true,
    "allowSyntheticDefaultImports": true,
    "resolveJsonModule": true
  }
}
EOL

  # Create Next.js specific TypeScript config
  cat > "$CONFIG_PATH/tsconfig.nextjs.json" << EOL
{
  "extends": "./tsconfig.base.json",
  "compilerOptions": {
    "target": "ES2020",
    "lib": ["DOM", "DOM.Iterable", "ESNext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "incremental": true,
    "module": "ESNext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "plugins": [
      {
        "name": "next"
      }
    ]
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules"]
}
EOL

  # Create Node.js specific TypeScript config
  cat > "$CONFIG_PATH/tsconfig.node.json" << EOL
{
  "extends": "./tsconfig.base.json",
  "compilerOptions": {
    "target": "ES2020",
    "module": "ESNext",
    "moduleResolution": "NodeNext",
    "outDir": "./dist",
    "rootDir": "./src",
    "declaration": true,
    "composite": true,
    "sourceMap": true
  }
}
EOL
fi

echo -e "\\n${GREEN}Successfully configured TypeScript!${NC}"
echo -e "${YELLOW}The following files were created/updated:${NC}"
echo -e "  - tsconfig.json"
echo -e "  - packages/config/tsconfig.base.json"
echo -e "  - packages/config/tsconfig.nextjs.json"
echo -e "  - packages/config/tsconfig.node.json\\n"
echo -e "${CYAN}Happy coding!${NC}"`;
}

function generatePnpmWorkspaceScript(details: string, technologies: string[]): string {
  return `#!/bin/bash

# Script to configure pnpm workspaces in the AI Workspace monorepo
# Generated for: Configure pnpm workspaces

# Set colors for better readability
GREEN='\\033[0;32m'
CYAN='\\033[0;36m'
YELLOW='\\033[1;33m'
RED='\\033[0;31m'
NC='\\033[0m' # No Color

echo -e "${CYAN}=== AI Workspace Monorepo - pnpm Workspace Configuration ===${NC}\\n"

# Create pnpm-workspace.yaml
echo -e "${YELLOW}Setting up pnpm workspace configuration...${NC}"

cat > pnpm-workspace.yaml << EOL
packages:
  - 'apps/*'
  - 'servers/*'
  - 'packages/*'
EOL

# Create or update package.json
echo -e "${YELLOW}Updating root package.json...${NC}"

cat > package.json << EOL
{
  "name": "ai-workspace",
  "version": "1.0.0",
  "private": true,
  "scripts": {
    "dev": "pnpm --filter shell-ui dev & pnpm --filter shell-ai dev",
    "build": "pnpm --filter '*' build",
    "start": "pnpm --filter shell-ui start & pnpm --filter shell-ai start",
    "lint": "pnpm --filter '*' lint",
    "clean": "rm -rf node_modules */*/node_modules */*/*/node_modules */*/.next */*/dist */*/*/dist",
    "create:app": "tsx scripts/create-app.js",
    "create:server": "tsx scripts/create-server.js",
    "create:package": "tsx scripts/create-package.js"
  },
  "engines": {
    "node": ">=18.0.0"
  }
}
EOL

# Ensure the scripts directory exists
mkdir -p scripts

# Create a sample script for creating a new app
cat > scripts/create-app.js << EOL
#!/usr/bin/env node

import { execSync } from 'child_process';
import fs from 'fs';
import path from 'path';
import readline from 'readline';

const rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout
});

// Get app name from command line arguments or prompt for it
const appName = process.argv[2];

if (!appName) {
  rl.question('Enter the name for your new app: ', (name) => {
    if (!name) {
      console.error('Error: App name is required');
      rl.close();
      process.exit(1);
    }
    createApp(name);
    rl.close();
  });
} else {
  createApp(appName);
  rl.close();
}

function createApp(name) {
  const appPath = path.join(process.cwd(), 'apps', name);
  
  // Check if the app already exists
  if (fs.existsSync(appPath)) {
    console.error(\`Error: An app with name '\${name}' already exists.\`);
    process.exit(1);
  }
  
  console.log(\`Creating new Next.js app: \${name}\`);
  console.log(\`Path: \${appPath}\`);
  
  try {
    // Create the app directory and structure
    fs.mkdirSync(path.join(appPath, 'src', 'app'), { recursive: true });
    fs.mkdirSync(path.join(appPath, 'src', 'components'), { recursive: true });
    fs.mkdirSync(path.join(appPath, 'src', 'lib'), { recursive: true });
    fs.mkdirSync(path.join(appPath, 'src', 'styles'), { recursive: true });
    
    // Create package.json
    const packageJson = {
      name: \`@workspace/\${name}\`,
      version: "0.1.0",
      private: true,
      scripts: {
        dev: "next dev",
        build: "next build",
        start: "next start",
        lint: "next lint"
      },
      dependencies: {
        next: "^13.4.0",
        react: "^18.2.0",
        "react-dom": "^18.2.0",
        "@workspace/ui": "workspace:*",
        "@workspace/shared": "workspace:*"
      },
      devDependencies: {
        "@types/node": "^18.0.0",
        "@types/react": "^18.0.0",
        "@types/react-dom": "^18.0.0",
        typescript: "^5.0.0",
        tailwindcss: "^3.3.0",
        autoprefixer: "^10.4.0",
        postcss: "^8.4.0"
      }
    };
    
    fs.writeFileSync(
      path.join(appPath, 'package.json'),
      JSON.stringify(packageJson, null, 2)
    );
    
    // Create tsconfig.json
    const tsConfig = {
      extends: "../../packages/config/tsconfig.nextjs.json",
      compilerOptions: {
        baseUrl: ".",
        paths: {
          "@/*": ["./src/*"],
          "@workspace/*": ["../../packages/*"]
        }
      },
      include: ["next-env.d.ts", "**/*.ts", "**/*.tsx"],
      exclude: ["node_modules"]
    };
    
    fs.writeFileSync(
      path.join(appPath, 'tsconfig.json'),
      JSON.stringify(tsConfig, null, 2)
    );
    
    // Create next.config.js
    const nextConfig = \`/** @type {import('next').NextConfig} */
const nextConfig = {
  reactStrictMode: true,
  transpilePackages: ["@workspace/ui", "@workspace/shared"]
}

module.exports = nextConfig
\`;
    
    fs.writeFileSync(path.join(appPath, 'next.config.js'), nextConfig);
    
    // Create tailwind.config.js
    const tailwindConfig = \`/** @type {import('tailwindcss').Config} */
module.exports = {
  presets: [require('../../packages/ui/tailwind.config.js')],
  content: [
    './src/**/*.{js,ts,jsx,tsx}',
    '../../packages/ui/src/**/*.{js,ts,jsx,tsx}'
  ],
  theme: {
    extend: {},
  },
  plugins: [],
}
\`;
    
    fs.writeFileSync(path.join(appPath, 'tailwind.config.js'), tailwindConfig);
    
    // Create postcss.config.js
    const postcssConfig = \`module.exports = {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}
\`;
    
    fs.writeFileSync(path.join(appPath, 'postcss.config.js'), postcssConfig);
    
    // Create a basic layout file
    const layout = \`import '@/styles/globals.css'
import { Inter } from 'next/font/google'

const inter = Inter({ subsets: ['latin'] })

export const metadata = {
  title: '\${name}',
  description: 'Generated by AI Workspace',
}

export default function RootLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return (
    <html lang="en">
      <body className={inter.className}>{children}</body>
    </html>
  )
}
\`;
    
    fs.writeFileSync(path.join(appPath, 'src', 'app', 'layout.tsx'), layout);
    
    // Create a simple page component
    const page = \`import { Button } from '@workspace/ui'

export default function Home() {
  return (
    <main className="flex min-h-screen flex-col items-center justify-center p-24">
      <h1 className="text-4xl font-bold mb-8">
        Welcome to {process.env.NEXT_PUBLIC_APP_NAME || '\${name}'}
      </h1>
      <p className="mb-4">
        This app was created using the AI Workspace monorepo structure
      </p>
      <Button>Get Started</Button>
    </main>
  )
}
\`;
    
    fs.writeFileSync(path.join(appPath, 'src', 'app', 'page.tsx'), page);
    
    // Create global CSS
    const globalCss = \`@tailwind base;
@tailwind components;
@tailwind utilities;
\`;
    
    fs.writeFileSync(path.join(appPath, 'src', 'styles', 'globals.css'), globalCss);
    
    // Create README.md
    const readme = \`# \${name}

This is a Next.js application created within the AI Workspace monorepo.

## Getting Started

First, run the development server:

\\\`\\\`\\\`bash
pnpm dev
\\\`\\\`\\\`

Open [http://localhost:3000](http://localhost:3000) with your browser to see the result.

## Learn More

To learn more about the technologies used:

- [Next.js Documentation](https://nextjs.org/docs)
- [Tailwind CSS Documentation](https://tailwindcss.com/docs)
- [ShadCN UI Documentation](https://ui.shadcn.com)
\`;
    
    fs.writeFileSync(path.join(appPath, 'README.md'), readme);
    
    console.log(\`\\nSuccessfully created \${name}!\`);
    console.log(\`To start the development server:\`);
    console.log(\`  cd apps/\${name}\`);
    console.log(\`  pnpm dev\\n\`);
    console.log(\`Happy coding!\`);
  } catch (error) {
    console.error('Error creating app:', error);
    process.exit(1);
  }
}
EOL

# Make the script executable
chmod +x scripts/create-app.js

echo -e "\\n${GREEN}Successfully configured pnpm workspaces!${NC}"
echo -e "${YELLOW}The following files were created/updated:${NC}"
echo -e "  - pnpm-workspace.yaml"
echo -e "  - package.json"
echo -e "  - scripts/create-app.js\\n"
echo -e "${CYAN}Happy coding!${NC}"`;
}

function generateCustomScript(details: string, technologies: string[]): string {
  return `#!/bin/bash

# Custom script for AI Workspace monorepo
# Generated based on user requirements

# Set colors for better readability
GREEN='\\033[0;32m'
CYAN='\\033[0;36m'
YELLOW='\\033[1;33m'
RED='\\033[0;31m'
NC='\\033[0m' # No Color

echo -e "${CYAN}=== AI Workspace Monorepo - Custom Script ===${NC}\\n"
echo -e "${YELLOW}Details:${NC} ${details}\\n"
echo -e "${YELLOW}Technologies:${NC} ${technologies.join(', ')}\\n"

# TODO: Implement script based on user details
# This is a placeholder for a custom script

echo -e "${GREEN}Script execution completed!${NC}"
echo -e "${CYAN}Happy coding!${NC}"`;
}
